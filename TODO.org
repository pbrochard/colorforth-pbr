* DONE string
   - pad -> buffer
  - new pad on each string init
  - s"  +"  ,s + word to end string
  - formatter s" test" +f" %s"

    b" This is" b+" a string" 123 b"test=%ld"+  btype  bdup bprint :to-store ~,b ^;

* exec
  - exec" ls" - bstdoud bstderr (to be freed)
  => launch" ls" read-out pclose
     ou 'dumpline process-out
     FILE *fp;
  char path[1035];

  /* Open the command for reading. */
  fp = popen("/bin/ls /etc/ 2>&1", "r");
  if (fp == NULL) {
    printf("Failed to run command\n" );
    exit(1);
  }

  /* Read the output a line at a time - output it. */
  while (fgets(path, sizeof(path), fp) != NULL) {
    printf("%s", path);
  }

  /* close */
  pclose(fp);

* regex ??? match + test. libpcre => regex.h

* network repl
* http repl (send html+js over network look at htmx and libhttp)

* DONE use a function pointer for color + remove color compile directive
dump entrie name or null => word to access entrie name reference
remove ~/.config at startup

====

* DONE ' function of previous color => ^ : compile  ~ execute
* DONE ' -> code instead of entry, ` stay entry
* DONE code> -> c>

* DONE dhere => dataspace in the heap
* DONE string => write in data space
* DONE [ ^code here ] => quotation:
      write code in here started with [
      at ] move code in data space
      leave code on the stack

* DONE stacktrace + current_entry => push entry `xt (comme pour see) du rstack
* DONE stack check => afficher current entry (voir dans rstack)

* DONE *!!- sigsev segfault dans main  : https://stackoverflow.com/a/554199 longjump juste avant main
* DONE catch : catchables returns N E => catch test sur E => drop si 0, call 'error si > 0 (possible: clear rstack, dépile rstack jusqu'à un 'try')

* DONE guess-a-number: guess prompt check with '?'

* DONE dump as C => init_stack dans un #defined soit malloc+fresh state soit static alloc from dump
